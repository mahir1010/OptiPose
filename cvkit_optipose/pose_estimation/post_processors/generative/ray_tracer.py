import numpy as np

from cvkit.pose_estimation import Part
from cvkit.pose_estimation.data_readers import CVKitDataStore3D
from cvkit.pose_estimation.post_processors.post_prcessor_interface import PostProcessor
from cvkit.pose_estimation.utils import normalize_vector, magnitude


class RayTracer(PostProcessor):
    PROCESS_NAME = "Ray Tracer"

    @staticmethod
    def generate_ray_builder_from_parts(part_1: str, part_2: str):
        """
        A function that generates a default build_ray function from two body parts as (part1 - part2).
        It returns the starting point and direction
        Args:
            part_1: target of ray
            part_2: source of ray
        """
        return lambda sk: [sk[part_2], sk[part_1] - sk[part_2]]

    def __init__(self, build_ray, surface_map, elevation_factor=0):
        """
        Traces ray generated by body parts from ray_sources and stores first point of intersection with one of the
        rectangular surfaces defined in surface_map.
        Args:
        build_ray: A function of body parts that outputs the ray to be traced in the form of [starting_point,direction]
        surface_map: A dictionary of surfaces where the surface name is the key and the value is a list of 3 3D vectors
                - the corner of the surface and two end_points of the sides s1 and s2. Normal will be calculated
                by s1 x s2. Therefore, order of the sides matter.
        elevation_factor: The z value of the direction vector will be adjusted by this factor as follows:
                direction[2] = direction[2] + abs(direction[2]*elevation_factor)
                It is used to elevate the direction of looking.
        """
        super(RayTracer, self).__init__()
        self.build_ray = build_ray
        for surface in surface_map:
            vectors = surface_map[surface]
            vectors[1] = np.subtract(vectors[1], vectors[0])
            vectors[2] = np.subtract(vectors[2], vectors[0])
            vectors.append(normalize_vector(np.cross(vectors[1], vectors[2])))
            surface_map[surface] = vectors
        self.surface_map = surface_map
        self.elevation_factor = elevation_factor

    def process(self, data_store):
        self.data_store = CVKitDataStore3D(list(self.surface_map.keys()), None)
        self.data_ready = False
        self.progress = 0
        for index, skeleton in data_store.row_iterator():
            self.progress = int(index / len(data_store) * 100)
            if self.PRINT and self.progress % 10 == 0:
                print(f'\r {self.PROCESS_NAME} {self.progress}% complete', end='')
            start, direction = self.build_ray(skeleton)
            direction[2] = direction[2] + abs(direction[2] * self.elevation_factor)
            direction = normalize_vector(direction)
            distance_map = {}
            point_map = {}
            for surface in self.surface_map:
                empty_part = Part([-1, -1, -1], surface, 0)
                self.data_store.set_part(index, empty_part)
                p = np.array(self.surface_map[surface][0])
                side_1 = np.array(self.surface_map[surface][1])
                side_2 = np.array(self.surface_map[surface][2])
                n = np.array(self.surface_map[surface][3])
                dot_p = np.dot(direction, n)
                if dot_p < 0:
                    t = np.dot(n, (p - start)) / dot_p
                    if t >= 0:
                        point_on_plane = (start + t * direction)
                        ray_to_point = np.subtract(point_on_plane, p)
                        projection_1 = (np.dot(ray_to_point, side_1) / magnitude(side_1))
                        projection_2 = (np.dot(ray_to_point, side_2) / magnitude(side_2))
                        if 0 <= projection_1 <= magnitude(side_1) and 0 <= projection_2 <= magnitude(side_2):
                            distance_map[surface] = t
                            point_map[surface] = point_on_plane
            if len(distance_map) > 0:
                first_intersection = sorted(list(distance_map.keys()), key=lambda x: magnitude(distance_map[x]))[0]
                self.data_store.set_part(index, Part(point_map[first_intersection], first_intersection, 1))
        self.data_ready = True
        self.progress = 100

    def get_output(self):
        if self.data_ready:
            return self.data_store
        else:
            return None
